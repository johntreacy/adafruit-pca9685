{
  "name": "onoff",
  "version": "0.3.0",
  "description": "GPIO access and interrupt detection on the BeagleBone or Raspberry Pi",
  "main": "onoff.js",
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "scripts": {
    "test": "echo \"Tests can only be run manually from the command line. They access hardware GPIOs.\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/fivdi/onoff.git"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "dependencies": {
    "epoll": "~0.1.0"
  },
  "keywords": [
    "gpio",
    "embedded",
    "interrupt",
    "beaglebone",
    "bbb",
    "bb",
    "raspberry",
    "raspi",
    "rpi",
    "pi",
    "linux"
  ],
  "author": {
    "name": "fivdi"
  },
  "license": "MIT",
  "gypfile": true,
  "readme": "## onoff\n\nGPIO access and interrupt detection with Node.js on Linux boards such as the\nBeagleBone or Raspberry Pi.\n\n## Installation\n\n    $ [sudo] npm install onoff\n\nonoff requires Node.js v0.8.0 or higher.\n\n## Usage\n\nAssume that there's an LED on GPIO #17 and a momentary push button on GPIO #18.\nWhen the button is pressed the LED should trun on, when it's released the LED\nshould turn off. This can be acheived with the following code:\n\n```js\nvar Gpio = require('onoff').Gpio,\n    led = new Gpio(17, 'out'),\n    button = new Gpio(18, 'in', 'both');\n\nbutton.watch(function(err, value) {\n    led.writeSync(value);\n});\n```\n\nHere two Gpio objects are being created. One called led for the LED on GPIO #17\nwhich is an output, and one called button for the momentary push button on\nGPIO #18 which is an input. In addition to specifying that the button is an\ninput, the constructors optional third argument is used to specify that 'both'\nrising and falling interrupt edges should be configured for the button GPIO as\nboth button presses and releases should be handled.\n\nAfter everything has been setup correctly, the buttons watch method is used to\nspecify a callback function to execute every time the button is pressed or\nreleased. The value argument passed to the callback function represents the\nstate of the button which will be 1 for pressed and 0 for released. This value\nis used by the callback to turn the LED on or off using its writeSync method.\n\nWhen the above program is running it can be terminated with ctrl-c. However,\nit doesn't free its resources. It also ignores the err argument passed to\nthe callback. Here's a slightly modified variant of the program that handles\nctrl-c gracefully and bails out on error. The resources used by the led and\nbutton Gpio objects are released by calling their unexport method.\n\n```js\nvar Gpio = require('onoff').Gpio,\n    led = new Gpio(17, 'out'),\n    button = new Gpio(18, 'in', 'both');\n\nbutton.watch(function(err, value) {\n    if (err) exit();\n    led.writeSync(value);\n});\n\nfunction exit() {\n    led.unexport();\n    button.unexport();\n    process.exit();\n}\n\nprocess.on('SIGINT', exit);\n```\n\n## News & Updates\n\n### onoff v0.3.0 breaking persistentWatch change\n\nThe persistentWatch option that was supported by onoff v0.1.2 through v0.2.3\nwas removed with onoff v0.3.0. As of v0.3.0 watchers are always persistent.\nNote that this is a breaking change as the persistentWatch option defaulted\nto false which resulted in one-shot watchers.\n\nIf you were explicitly setting persistentWatch to true, the migration step is\neasy, simply remove the persistentWatch option.\n\nIf you were explicitly setting persistentWatch to false, or letting it default\nto false, you'll need to re-work your code. If one-shot watchers are needed,\nthe effect can be acheived by calling unwatch or unwatchAll in the watcher\ncallback the first time it's called.\n\n## How does it work?\n\nInternally onoff uses sysfs files located at /sys/class/gpio to access GPIOs\nand the [Node.js epoll module](https://github.com/fivdi/epoll) to detect\nhardware interrupts. It can detect several thousand interrupts per second on\nboth the BeagleBone and the Raspberry Pi.\n\n## API\n\nonoff provides a constructor function called Gpio which can be used to make\nGpio objects corresponding to Linux GPIOs. The Gpio methods available are as\nfollows:\n\n  * [Gpio](https://github.com/fivdi/onoff/blob/master/onoff.js#L9-L36) - Constructor\n  * read(callback) - Read GPIO value asynchronously\n  * readSync() - Read GPIO value synchronously\n  * write(value, callback) - Write GPIO value asynchronously\n  * writeSync(value) - Write GPIO value synchronously\n  * watch(callback) - Watch for hardware interrupts on the GPIO. Inputs and\n    outputs can be watched. The edge argument that was passed to the\n    constructor determines which hardware interrupts are watcher for.\n  * unwatch(callback) - Stop watching for hardware interrupts on the GPIO\n  * unwatchAll() - Remove all watchers for the GPIO\n  * direction() - Read GPIO direction\n  * edge() - Read GPIO interrupt generating edge\n  * options() - Get GPIO options\n  * unexport() - Reverse the effect of exporting the GPIO to userspace\n\nGPIOs on Linux are identified by unsigned integers. These are the numbers that\nshould be passed to the onoff Gpio constructor function when exporting GPIOs\nto userspace. For example, pin P1_11 on the Raspberry Pi P1 expansion header\ncorresponds to GPIO #17 in Raspbian Linux. 17 is therefore the number to pass\nto the onoff Gpio constructor when using pin P1_11 on the P1 expansion header.\n\n## Synchronous API\n\nBlink the LED on GPIO #17 for 5 seconds:\n\n```js\nvar Gpio = require('onoff').Gpio, // Constructor function for Gpio objects.\n    led = new Gpio(17, 'out'),    // Export GPIO #17 as an output.\n    iv;\n\n// Toggle the state of the LED on GPIO #17 every 200ms.\n// Here synchronous methods are used. Asynchronous methods are also available.\niv = setInterval(function() {\n    led.writeSync(led.readSync() === 0 ? 1 : 0); // 1 = on, 0 = off :)\n}, 200);\n\n// Stop blinking the LED and turn it off after 5 seconds.\nsetTimeout(function() {\n    clearInterval(iv); // Stop blinking\n    led.writeSync(0);  // Turn LED off.\n    led.unexport();    // Unexport GPIO and free resources\n}, 5000);\n```\n\n## Asynchronous API\n\nBlink the LED on GPIO #17 for 5 seconds:\n\n```js\nvar Gpio = require('onoff').Gpio, // Constructor function for Gpio objects.\n    led = new Gpio(17, 'out');    // Export GPIO #17 as an output.\n\n// Toggle the state of the LED on GPIO #17 every 200ms 'count' times.\n// Here asynchronous methods are used. Synchronous methods are also available.\n(function blink(count) {\n    if (count <= 0) return led.unexport();\n\n    led.read(function(err, value) {  // Asynchronous read.\n        if (err) throw err;\n\n        led.write(value === 0 ? 1 : 0, function(err) { // Asynchronous write.\n            if (err) throw err;\n        });\n    });\n\n    setTimeout(function() {\n        blink(count - 1);\n    }, 200);\n})(20);\n```\n\n## Configuring pull-up and pull-down resistors\n\nAs onoff plays well with the quick2wire gpio-admin and the WiringPi gpio\nutilities, either of these tools can be used to configure pull-up and pull-down\nresistors on th Pi.\n\n## Benchmarks\n\nThree of the onoff tests are used to monitor performance:\n\n  * performance-async.js - determine max. no. of write ops per seconds\n  * performance-sync.js - determine max. no. of writeSync ops per second\n  * performance-interrupt.js - determine max. no. of interrupts per second\n\nThe average of ten runs of these tests using onoff v0.2.3 are shown in the\nfollowing tables.\n\n**BeagleBone, 720MHz, Ångström v2012.12, Kernel 3.8.13:**\n\nNode.js | write ops / sec | writeSync ops / sec | interrupts / sec\n:---: | ---: | ---: | ---:\nv0.11.7 | 6399 | 84334 | 5519\nv0.10.20 | 4925 | 45713 | 4561\n\n**BeagleBone Black, 1GHz, Ångström v2012.12, Kernel 3.8.13:**\n\nNode.js | write ops / sec | writeSync ops / sec | interrupts / sec\n:---: | ---: | ---: | ---:\nv0.11.8 | 8446 | 100698 | 7323\n\n**Raspberry Pi, 700Mhz, Raspbian, Kernel 3.6.11+:**\n\nNode.js | write ops / sec | writeSync ops / sec | interrupts / sec\n:---: | ---: | ---: | ---:\nv0.11.07 | 3355 | 49651 | 2550\nv0.10.8 | 2772 | 31825 | 2297\n\n## How to handle superuser issues\n\nIn gereral, superuser privileges are required for exporting and using GPIOs.\nHowever, running all processes that access GPIOs as the superuser will be\nunacceptable for most. There are several ways to resolve this issue.\n\n**Resolving superuser issues with onoff**\n\nonoff has built in functionality which can be leveraged to resolve superuser\nissues. Let's assume that the application is the led/button example from\nabove.\n\nStep 1 - Export GPIOs as superuser\n\nCreate a simple program for exporting GPIOs and execute this program with\nsuperuser privileges. In addition to exporting the GPIOs, this program will\nautomatically change the access permissions for the GPIO value files giving\nall users read and write access.\n\n```js\nvar Gpio = require('onoff').Gpio,\n    led = new Gpio(17, 'out'),\n    button = new Gpio(18, 'in', 'both');\n```\n\nStep 2 - The application can be run by a non-superuser\n\nAfter the program from step one has been executed by the superuser, the\napplication itself can be executed by a non-superuser. The Gpio constructor\nwill detect whether a GPIO has already been exported to userspace and will not\nattempt to export it again. The value of the GPIO can be accessed as all\nusers have read and write access to the value file. Note that unlike the\ninitial led/button example, the applications exit function does not attempt\nto unexport the GPIOs when it terminates.\n\n```js\nvar Gpio = require('onoff').Gpio,\n    led = new Gpio(17, 'out'),\n    button = new Gpio(18, 'in', 'both');\n\nbutton.watch(function(err, value) {\n    if (err) exit();\n    led.writeSync(value);\n});\n\nfunction exit() {\n    process.exit();\n}\n\nprocess.on('SIGINT', exit);\n```\n\nStep 3 - Unexport GPIOs as superuser\n\nAfter the application has terminated, a third program can be executed by the\nsuperuser to unexport the appropriate GPIOs.\n\n```js\nvar Gpio = require('onoff').Gpio,\n    led = new Gpio(17, 'out'),\n    button = new Gpio(18, 'in', 'both');\n\nled.unexport();\nbutton.unexport();\n```\n\n**Resolving superuser issues on the Pi with quick2wire-gpio-admin**\n\nAfter [quick2wire-gpio-admin](https://github.com/quick2wire/quick2wire-gpio-admin)\nhas been successfully installed, the gpio-admin utility can be used to\nexport/unexport GPIOs and the application can be executed without superuser\nprivileges. Let's assume that the application is the led/button example from\nabove.\n\nStep 1 - Export GPIOs with gpio-admin\n\nRun the following commands to export GPIO #17 and #18:\n\n```bash\ngpio-admin export 17\ngpio-admin export 18\n```\n\nStep 2 - Run the application\n\nNow the application can be executed without superuser privileges. Note that\nunlike the initial led/button example, the applications exit function does\nnot attempt to unexport the GPIOs when it terminates.\n\n```js\nvar Gpio = require('onoff').Gpio,\n    led = new Gpio(17, 'out'),\n    button = new Gpio(18, 'in', 'both');\n\nbutton.watch(function(err, value) {\n    if (err) exit();\n    led.writeSync(value);\n});\n\nfunction exit() {\n    process.exit();\n}\n\nprocess.on('SIGINT', exit);\n```\n\nStep 3 - Unxport GPIOs with gpio-admin\n\nAfter the application has terminated, run the following commands to unexport\nGPIO #17 and #18:\n\n```bash\ngpio-admin unexport 17\ngpio-admin unexport 18\n```\n\n**Resolving superuser issues on the Pi with the WiringPi gpio utility**\n\nAfter the [WiringPi gpio utility](http://wiringpi.com/the-gpio-utility/)\nhas been successfully installed, it can be used to export/unexport GPIOs and\nthe application can be executed without superuser privileges. Let's assume that\nthe application is the led/button example from above.\n\nStep 1 - Export GPIOs with gpio\n\nRun the following commands to export GPIO #17 and #18:\n\n```bash\ngpio export 17 out\ngpio export 18 in\n```\n\nStep 2 - Run the application\n\nNow the application can be executed without superuser privileges. Note that\nunlike the initial led/button example, the applications exit function does\nnot attempt to unexport the GPIOs when it terminates.\n\n```js\nvar Gpio = require('onoff').Gpio,\n    led = new Gpio(17, 'out'),\n    button = new Gpio(18, 'in', 'both');\n\nbutton.watch(function(err, value) {\n    if (err) exit();\n    led.writeSync(value);\n});\n\nfunction exit() {\n    process.exit();\n}\n\nprocess.on('SIGINT', exit);\n```\n\nStep 3 - Unxport GPIOs with gpio\n\nAfter the application has terminated, run the following commands to unexport\nGPIO #17 and #18:\n\n```bash\ngpio unexport 17\ngpio unexport 18\n```\n\n## Additional Information\n\nonoff has been tested on the BeagleBone (Ångström) and Raspberry Pi (Raspbian).\nThe suitability of onoff for a particular Linux board is highly dependent on\nhow GPIO interfaces are made available on that board. The\n[GPIO interfaces](http://www.kernel.org/doc/Documentation/gpio.txt)\ndocumentation describes GPIO access conventions rather than standards that must\nbe followed so GPIO can vary from platform to platform. For example, onoff\nrelies on sysfs files located at /sys/classes/gpio being available. However,\nthese sysfs files for userspace GPIO are optional and may not be available on a\nparticular platform.\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/fivdi/onoff/issues"
  },
  "_id": "onoff@0.3.0",
  "_from": "onoff@"
}
