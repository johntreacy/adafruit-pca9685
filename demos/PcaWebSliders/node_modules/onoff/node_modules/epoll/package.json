{
  "name": "epoll",
  "version": "0.1.2",
  "description": "A low-level Node.js binding for the Linux epoll API",
  "main": "epoll.js",
  "directories": {
    "example": "example",
    "test": "test"
  },
  "scripts": {
    "test": "echo \"Tests can only be run manually from the command line.\" && exit 1",
    "install": "node-gyp rebuild"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/fivdi/epoll.git"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "dependencies": {
    "nan": "~0.6.0"
  },
  "keywords": [
    "epoll",
    "epollpri",
    "poll",
    "pollpri",
    "gpio",
    "interrupt",
    "linux"
  ],
  "author": {
    "name": "fivdi"
  },
  "license": "MIT",
  "gypfile": true,
  "readme": "## epoll\n\nA low-level Node.js binding for the Linux epoll API for monitoring multiple\nfile descriptors to see if I/O is possible on any of them.\n\nThis module was initially written to detect EPOLLPRI events indicating that\nurgent data is available for reading. EPOLLPRI events are triggered by\ninterrupt generating [GPIO](https://www.kernel.org/doc/Documentation/gpio.txt)\npins. The epoll module is used by [onoff](https://github.com/fivdi/onoff)\nto detect such interrupts.\n\n## Installation\n\n    $ [sudo] npm install epoll\n\n## API\n\n  * Epoll(callback) - Constructor. The callback is called when epoll events\n    occur and it gets three arguments (err, fd, events).\n  * add(fd, events) - Register file descriptor fd for the event types specified\n    by events.\n  * remove(fd) - Deregister file descriptor fd.\n  * modify(fd, events) - Change the event types associated with file descriptor\n    fd to those specified by events.\n  * close() - Deregisters all file descriptors and free resources.\n\nEvent Types\n\n  * Epoll.EPOLLIN\n  * Epoll.EPOLLOUT\n  * Epoll.EPOLLRDHUP\n  * Epoll.EPOLLPRI\n  * Epoll.EPOLLERR\n  * Epoll.EPOLLHUP\n  * Epoll.EPOLLET\n  * Epoll.EPOLLONESHOT\n\nEvent types can be combined with | when calling add or modify. For example,\nEpoll.EPOLLPRI | Epoll.EPOLLONESHOT could be passed to add to detect a single\nGPIO interrupt.\n\n## Example - Watching Buttons\n\nThe following example shows how epoll can be used to detect interrupts from a\nmomentary push-button connected to GPIO #18 (pin P1-12) on the Raspberry Pi.\nThe source code is available in the [example directory]\n(https://github.com/fivdi/epoll/tree/master/example/watch-button) and can\neasily be modified for using a different GPIO on the Pi or a different platform\nsuch as the BeagleBone.\n\nThe first step is to export GPIO #18 as an interrupt generating input using\nthe export bash script from the examples directory.\n\n    $ [sudo] ./export\n\nexport:\n```bash\n#!/bin/sh\necho 18 > /sys/class/gpio/export\necho in > /sys/class/gpio/gpio18/direction\necho both > /sys/class/gpio/gpio18/edge\n```\n\nThen run watch-button to be notified every time the button is pressed and\nreleased. If there is no hardware debounce circuit for the push-button, contact\nbounce issues are very likely to be visible on the console output.\nwatch-button terminates automatically after 30 seconds.\n\n    $ [sudo] node watch-button\n\nwatch-button:\n```js\nvar Epoll = require('epoll').Epoll,\n  fs = require('fs'),\n  valuefd = fs.openSync('/sys/class/gpio/gpio18/value', 'r'),\n  buffer = new Buffer(1);\n\n// Create a new Epoll. The callback is the interrupt handler.\nvar poller = new Epoll(function (err, fd, events) {\n  // Read GPIO value file. Reading also clears the interrupt.\n  fs.readSync(fd, buffer, 0, 1, 0);\n  console.log(buffer.toString() === '1' ? 'pressed' : 'released');\n});\n\n// Read the GPIO value file before watching to\n// prevent an initial unauthentic interrupt.\nfs.readSync(valuefd, buffer, 0, 1, 0);\n\n// Start watching for interrupts.\npoller.add(valuefd, Epoll.EPOLLPRI);\n\n// Stop watching after 30 seconds.\nsetTimeout(function () {\n  poller.remove(valuefd).close();\n}, 30000);\n```\n\nWhen watch-button has terminated, GPIO #18 can be unexported using the\nunexport bash script.\n\n    $ [sudo] ./unexport\n\nunexport:\n```bash\n#!/bin/sh\necho 18 > /sys/class/gpio/unexport\n```\n\n## Example - Interrupts per Second\n\nThe following example shows how epoll can be used to detect interrupts when the\nstate of an LED connected to GPIO #38 on the BeagleBone changes.\nThe source code is available in the [example directory]\n(https://github.com/fivdi/epoll/tree/master/example/watch-led) and can\neasily be modified for using a different GPIO on the BeagleBone or a different\nplatform such as the Raspberry Pi.\n\nThe goal here is to determine how many interrupts can be handled per second.\n\nThe first step is to export GPIO #38 as an interrupt generating output (!) using\nthe export bash script from the examples directory.\n\n    $ [sudo] ./export\n\nexport:\n```bash\n#!/bin/sh\necho 38 > /sys/class/gpio/export\necho out > /sys/class/gpio/gpio38/direction\necho both > /sys/class/gpio/gpio38/edge\n```\n\nThen run watch-led. watch-led toggles the state of the LED every time it\ndetects an interrupt. Each toggle will trigger the next interrupt. After five\nseconds, watch-led prints the number of interrupts it detected per second. The\nLED is turned on and off several thousand times per second so no blinking will\nbe visible, the LED will light at about half brightness.\n\n    $ [sudo] node watch-led\n\nwatch-led:\n```js\nvar Epoll = require('epoll').Epoll,\n  fs = require('fs'),\n  valuefd = fs.openSync('/sys/class/gpio/gpio38/value', 'r+'),\n  value = new Buffer(1),  // The three Buffers here are global\n  zero = new Buffer('0'), // to improve performance.\n  one = new Buffer('1'),\n  count = 0,\n  time;\n\n// Create a new Epoll. The callback is the interrupt handler.\nvar poller = new Epoll(function (err, fd, events) {\n  var nextValue;\n\n  count++;\n\n  // Read GPIO value file. Reading also clears the interrupt.\n  fs.readSync(fd, value, 0, 1, 0);\n\n  // Toggle GPIO value. This will eventually result\n  // in the next interrupt being triggered.\n  nextValue = value[0] === zero[0] ? one : zero;\n  fs.writeSync(fd, nextValue, 0, nextValue.length, 0);\n});\n\ntime = process.hrtime(); // Get start time.\n\n// Start watching for interrupts. This will trigger the first interrupt\n// as the value file already has data waiting for a read.\npoller.add(valuefd, Epoll.EPOLLPRI);\n\n// Print interrupt rate to console after 5 seconds.\nsetTimeout(function () {\n  var rate;\n\n  time = process.hrtime(time); // Get run time.\n  rate = Math.floor(count / (time[0] + time[1] / 1E9));\n  console.log(rate + ' interrupts per second');\n\n  // Stop watching.\n  poller.remove(valuefd).close();\n}, 5000);\n```\n\nWhen watch-led has terminated, GPIO #38 can be unexported using the\nunexport bash script.\n\n    $ [sudo] ./unexport\n\nunexport:\n```bash\n#!/bin/sh\necho 38 > /sys/class/gpio/unexport\n```\n\nHere are some results from the \"Interrupts per Second\" example.\n\n**BeagleBone, 720MHz, Ångström v2012.12, Kernel 3.8.13, epoll v0.0.6:**\n\nNode.js | Interrupts / Second\n:---: | ---:\nv0.11.7 | 7152\nv0.10.20 | 5861\nv0.8.22 | 6098\n\n**BeagleBone Black, 1GHz, Ångström v2012.12, Kernel 3.8.13, epoll v0.0.8:**\n\nNode.js | Interrupts / Second\n:---: | ---:\nv0.11.8 | 9760\n\n**Raspberry Pi, 700Mhz, Raspbian, Kernel 3.2.27+, epoll v0.0.6:**\n\nNode.js | Interrupts / Second\n:---: | ---:\nv0.11.07 | 4071\nv0.10.16 | 3530\nv0.8.14 | 3591\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/fivdi/epoll/issues"
  },
  "_id": "epoll@0.1.2",
  "_from": "epoll@~0.1.0"
}
